<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[TODO: Come Up With Clever Title]]></title>
  <link href="http://charlesjohnson.github.com/atom.xml" rel="self"/>
  <link href="http://charlesjohnson.github.com/"/>
  <updated>2013-03-17T08:40:00-07:00</updated>
  <id>http://charlesjohnson.github.com/</id>
  <author>
    <name><![CDATA[Charles Johnson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Copying Files as Part of a Chef Recipe]]></title>
    <link href="http://charlesjohnson.github.com/blog/2013/03/12/copying-files-as-part-of-a-chef-recipe/"/>
    <updated>2013-03-12T16:54:00-07:00</updated>
    <id>http://charlesjohnson.github.com/blog/2013/03/12/copying-files-as-part-of-a-chef-recipe</id>
    <content type="html"><![CDATA[<p>It&#8217;s a little puzzling to me that while Chef has the <a href="http://docs.opscode.com/chef/resources.html#remote_file">remote_file</a> resource for downloading files from remote hosts, it doesn&#8217;t have a similar mechanism in the <a href="http://docs.opscode.com/chef/resources.html#remote_file">file</a> resource to copy files as part of a recipe. While there&#8217;s usually a workaround and unnecessary file copies should be discourage in a deploy or configuration pattern, sometimes outside actors beyond our control may place an essential file at an inconvenient and non-configurable location on the filesystem.</p>

<p>One good example of this occurs when a <a href="http://www.vagrantup.com">Vagrant</a> guest with the <a href="http://docs-v1.vagrantup.com/v1/docs/provisioners/chef_server.html">Chef-Server</a> provisioner has the <a href="http://community.opscode.com/cookbooks/chef-cent">chef-client</a> cookbook in the <a href="http://docs.opscode.com/essentials_node_object_run_lists.html">run_list</a>. When Vagrant invokes the Chef-Server provisioner, it writes out a <code>client.rb</code> file to the guest filesystem at <code>/tmp/vagrant-chef-1/client.rb</code>, along with a few others. The provisioner then runs chef-client in the guest VM with the <code>-c /tmp/vagrant-chef-1/client.rb</code> command-line flag, redirecting chef-client to the config file at this location.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>/tmp/vagrant-chef-1
</span><span class='line'>|-- client.rb
</span><span class='line'>|-- dna.json
</span><span class='line'><span class="sb">`</span>-- validation.pem
</span></code></pre></td></tr></table></div></figure>


<p>By contrast, when chef-client is started as a daemon by the <code>chef-client::service</code> recipe, chef-client looks for configuration at the location <code>#{node['chef-client']['conf_dir']}/client.rb</code>, which defaults to <code>/etc/chef/client.rb.</code> So what happens if the recipe being tested with Vagrant adds <code>recipe[chef-client::service]</code> to the node&#8217;s run_list?<!--more--></p>

<p><a href="http://i.imgur.com/wMT8GvR"><img class="center" src="http://i.imgur.com/wMT8GvR.png" width="576" height="539" title="Chef provisioner flowchart" alt="A flowchart diagram of Vagrant running chef-client with the chef-server provisioner"></a></p>

<p>The Vagrant provisioner will generate a client.rb file at <code>/tmp/vagrant-chef-1/client.rb</code>, and then start an instance of chef-client using this configuration file. When the provisioning instance of chef-client converges the <code>chef-client::service</code> recipe, it will try to start a second, daemonized copy of chef-client via an init script. This second instance of chef-client will look for configuration at the location <code>#{node['chef-client']['conf_dir']}/client.rb</code>, which defaults to <code>/etc/chef/client.rb</code>. But because there is no config file at this location, the service will not start, the provisioning chef-client run will exit with an error, and the vagrant provision will fail.</p>

<p>It&#8217;s tricky to use Vagrant to test code that starts chef-client as a service during the provisioner. To fix this issue, we have to either tell the daemonized instance of chef-client to look for the configuration file in another location, or we have to copy the configuration file to the location that the daemon is expecting. It turns out that redirecting the daemon by changing the attribute isn&#8217;t the best choice: Unlike Vagrant&#8217;s <a href="http://docs-v1.vagrantup.com/v1/docs/provisioners/chef_solo.html">Chef-Solo</a> provisioner, it&#8217;s not possible to inject node attributes directly into the Chef-Server provisioner&#8217;s run via the Vagrantfile. In addition, because Vagrant writes out the <code>client.rb</code> file to <code>/tmp/vagrant-chef-1/client.rb</code>, setting the attribute to this location would set an uncomfortable (and unwise) precedent. So instead, the best solution is arguably to wait until Vagrant writes out the configuration file at <code>/tmp/vagrant-chef-1/client.rb</code>, and then copy it to <code>/etc/chef/client.rb</code> before attempting to converge the <code>chef-cent::service</code> recipe.</p>

<p>This code should should take care of this use case. It assumes that the attribute <code>node['chef-client']['conf_dir']</code> has been set.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="o">::</span><span class="no">File</span><span class="o">.</span><span class="n">exist?</span><span class="p">(</span><span class="s2">&quot;/tmp/vagrant-chef-1/client.rb&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">ruby_block</span> <span class="s2">&quot;Copy Chef config file if running in a Vagrant guest&quot;</span> <span class="k">do</span>
</span><span class='line'>   <span class="n">block</span> <span class="k">do</span>
</span><span class='line'>    <span class="o">::</span><span class="no">FileUtils</span><span class="o">.</span><span class="n">cp</span> <span class="s2">&quot;/tmp/vagrant-chef-1/client.rb&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">node</span><span class="o">[</span><span class="s1">&#39;chef-client&#39;</span><span class="o">][</span><span class="s1">&#39;conf_dir&#39;</span><span class="o">]</span><span class="si">}</span><span class="s2">/client.rb&quot;</span>
</span><span class='line'>   <span class="k">end</span>
</span><span class='line'>   <span class="k">if</span> <span class="o">::</span><span class="no">File</span><span class="o">.</span><span class="n">exist?</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">node</span><span class="o">[</span><span class="s1">&#39;chef-client&#39;</span><span class="o">][</span><span class="s1">&#39;conf_dir&#39;</span><span class="o">]</span><span class="si">}</span><span class="s2">/client.rb&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="n">not_if</span> <span class="p">{</span> <span class="o">::</span><span class="no">FileUtils</span><span class="o">.</span><span class="n">compare_file</span><span class="p">(</span><span class="s2">&quot;/tmp/vagrant-chef-1/client.rb&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">node</span><span class="o">[</span><span class="s1">&#39;chef-client&#39;</span><span class="o">][</span><span class="s1">&#39;conf_dir&#39;</span><span class="o">]</span><span class="si">}</span><span class="s2">/client.rb&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>   <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>What this does: First check to see if the source file exists. If it does, check to see if the target file exists. If both files exist, then compare them to see if they are identical. If the files are not identical, or if the target file does not exist, then copy the source file to the target file location, overwriting the target file if present. In all other cases, do nothing.</p>

<p>Drop this in a recipe that&#8217;s included before the <code>chef-client::service</code> recipe as part of the run_list in the Vagrantfile, and the Vagrant provision run will now complete. <strong>Be careful, there are security implications in this example!</strong> The code itself is fine, but because <code>/tmp</code> is typically world-writeable, we can&#8217;t rely on Vagrant being the only outside actor to leave a client.rb at this location. Proceed with caution. This is a good example of why copying files as part of a recipe is usually discouraged.</p>

<p>One note: While I haven&#8217;t done any direct testing, it looks like Ruby&#8217;s <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/fileutils/rdoc/FileUtils.html#method-c-compare_file_">FileUtils.compare_file()</a> method works by streaming both files and comparing them, so it should work with binaries. However, I could imagine this being very memory-hungry if attempted with large files. Or maybe not? I&#8217;m a lousy Rubyist.</p>
]]></content>
  </entry>
  
</feed>
